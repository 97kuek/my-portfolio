---
title: XFLR5の解析結果からXROTORのパラメータを自動算出するツールを作った話
description: 'AEROSECTIONのパラメータ設定方法'
pubDate: '2025-12-17'
tags: ['設計', '人力飛行機', '技術解説', 'XROTOR', 'XFLR5']
---

こんにちは。早稲田大学宇宙航空研究会（WASA）鳥人間プロジェクトで翼班をやっている植木です。
普段は主翼や尾翼の製作がメインですが、最近はプロペラ設計のサポートも行っています。

今回は、人力飛行機のプロペラ設計において避けては通れない **「XROTORのパラメータ設定」** を、Pythonと数学を使って自動化した話をします。

「XROTORの入力ファイル、作るの面倒だな...」と思っている設計者の方や、「そもそもあの数字ってどう決めるの？」という新入生に向けた記事です。

![プロペラ](../../assets/propeller.jpg)
*25年度鳥人間コンテスト出場機体のプロペラ。かっこいい！*

## なぜ作ったのか？

MITのMark Drela教授が開発した **XROTOR** は、低レイノルズ数領域におけるプロペラ設計のデファクトスタンダードです。しかし、その核心部分である翼型定義セクション（`AEROSECTION`）には、長年抱えられてきた課題がありました。

それは、**「パラメータ設定が、設計者の"職人芸"になりがち」** という点です。

XROTORは計算コスト削減のため、翼型特性を生の極曲線データ（Polar Curve）ではなく、係数を用いた**近似関数**として保持します。従来、これらの値はグラフを目視して定規を当てたり、手計算で算出したりしていましたが、このアナログな手法には以下の問題がありました。

1.  **再現性の欠如**: 人によって読み取る値（傾きや切片）が変わり、設計結果がブレる。
2.  **物理的整合性**: どこまでを線形領域とするか、どの範囲でフィッティングするかの基準が曖昧。

そこで今回は、XFLR5による粘性解析データを「正」とし、**「誰がやっても同じ結果になり、かつ数学的に妥当なパラメータ」** を一意に生成する手法をまとめました。

---

## XROTORが求めている13のパラメータ

まず、敵を知りましょう。XROTORの `AERO` メニューで要求されるのは以下の13項目です。

| No. | Parameter | Symbol | 意味 |
| :--- | :--- | :---: | :--- |
| 1 | **Alpha at Zero Lift** | $\alpha_{0}$ | 揚力が0になる迎え角 |
| 2 | **Lift Slope** | $dC_L/d\alpha$ | 線形区間における揚力傾斜 |
| 3 | **Lift Slope @stall** | - | 失速直前の揚力傾斜 |
| 4 | **Max CL** | $C_{L,max}$ | 最大揚力係数 |
| 5 | **Min CL** | $C_{L,min}$ | 最小揚力係数 |
| 6 | **CL increment to stall** | $\Delta C_L$ | 失速域の$C_L$増加分 |
| 7 | **Min Drag** | $C_{D,min}$ | 最小抗力係数 |
| 8 | **Drag Scaling Factor** | $k$ | 抗力曲線の広がり係数 |
| 9 | **CL at Min Drag** | $C_{L,opt}$ | 最小抗力を与える揚力係数 |
| 10 | **Ref. Re Number** | $Re_{ref}$ | 解析レイノルズ数 |
| 11 | **Re Scaling Exp** | $n$ | レイノルズ数スケーリング指数 |
| 12 | **Cm** | $C_m$ | ピッチングモーメント係数 |
| 13 | **Mcrit** | $M_{crit}$ | 臨界マッハ数 |

これらを**XFLR5の解析ログ（テキストファイル）から自動計算**することを目指します。

---

## 理論と実装：どうやって計算するのか

本ツールの肝となるのは、**最小二乗法によるカーブフィッティング**です。
「なんとなくグラフに重なる線」を引くのではなく、数学的に誤差が最小になる係数を求めます。

### 1. 抗力（Drag）のモデル化：2次関数の係数比較

ここが一番のポイントです。
XROTORは内部で、抗力係数 $C_D$ は揚力係数 $C_L$ に対して**放物線を描く**と仮定しています。その定義式は以下の通りです。

$$
C_D = C_{D,min} + k (C_L - C_{L,opt})^2 \quad \cdots (1)
$$

ここで、$C_{D,min}$ は放物線の底の高さ、$C_{L,opt}$ は底の横位置、$k$ は放物線の開き具合を表します。

一方、Python（NumPyなど）を使って、解析データ $(C_L, C_D)$ の点群に対して2次多項式のフィッティングを行うと、以下の形の式が得られます。

$$
C_D = a {C_L}^2 + b {C_L} + c \quad \cdots (2)
$$

私たちは今、解析データから得られた $(2)$ の係数 $a, b, c$ は分かっています。これを使って、$(1)$ の未知数 $k, C_{L,opt}, C_{D,min}$ を求めたいわけです。

#### 式変形による導出

式$(1)$を展開して、式$(2)$と同じ形（$C_L$の降べきの順）に整理してみましょう。

$$
\begin{aligned}
C_D &= C_{D,min} + k (C_L^2 - 2 C_{L,opt} C_L + C_{L,opt}^2) \\
    &= k C_L^2 - 2k C_{L,opt} C_L + (C_{D,min} + k C_{L,opt}^2) \quad \cdots (1')
\end{aligned}
$$

式$(1')$と式$(2)$の係数を比較します（係数比較法）。

**① 2次の項の比較**
$$k = a$$
これで一つ目のパラメータ **Drag Scaling Factor ($k$)** が求まりました。

**② 1次の項の比較**
$$
b = -2k C_{L,opt}
$$
これに $k=a$ を代入して変形すると、
$$
b = -2a C_{L,opt} \quad \Rightarrow \quad C_{L,opt} = -\frac{b}{2a}
$$
これで二つ目のパラメータ **CL at Min Drag ($C_{L,opt}$)** が求まりました。これは2次関数の軸の公式 $x = -b/2a$ そのものですね。

**③ 定数項の比較**
$$
c = C_{D,min} + k C_{L,opt}^2
$$
これに $k=a$ と $C_{L,opt} = -b/2a$ を代入して変形します。
$$
\begin{aligned}
C_{D,min} &= c - k C_{L,opt}^2 \\
          &= c - a \left( -\frac{b}{2a} \right)^2 \\
          &= c - a \frac{b^2}{4a^2} \\
          &= c - \frac{b^2}{4a}
\end{aligned}
$$
これで三つ目のパラメータ **Min Drag ($C_{D,min}$)** が求まりました。

まとめると、プログラムで計算すべき式は以下のようになります。

> * **$k = a$**
> * **$C_{L,opt} = -b / 2a$**
> * **$C_{D,min} = c - b^2 / 4a$**



### 2. 揚力（Lift）のモデル化：線形近似

揚力曲線については、失速していない範囲では**直線（線形）**になります。
そこで、モデル式を以下のように置きます。

$$
C_L = G \cdot \alpha + I \quad \cdots (3)
$$
（$G$: 傾き, $I$: 切片, $\alpha$: 迎え角）

ここで重要なのが**「どの範囲のデータを使うか」**です。失速域のデータを含めて直線を引くと誤差が出ます。
本ツールでは、**「抗力が最小になる点（$C_{L,opt}$）の近くは、絶対に失速していない」**という物理的考察に基づき、その近傍データのみを使って1次近似（回帰分析）を行います。

得られた傾き $G$ と切片 $I$ から、パラメータを導出します。

**① Lift Slope（揚力傾斜）**
直線の傾きそのものです。
$$\text{Lift Slope} = G$$

**② Alpha at Zero Lift（ゼロ揚力角 $\alpha_0$）**
揚力 $C_L$ が 0 になるときの $\alpha$ です。式$(3)$に $C_L=0, \alpha=\alpha_0$ を代入します。
$$
0 = G \cdot \alpha_0 + I \quad \Rightarrow \quad \alpha_0 = - \frac{I}{G}
$$

これで揚力系の主要パラメータも一意に決まりました。

---

## 実装のポイント：線形領域のフィルタリング

理論通りに計算するためには、「きれいなデータ」だけ抽出する前処理が重要です。
具体的には、ドラッグポーラー上の局所的な傾き（差分）$s_i$ を監視します。

$$
s_i = \frac{d C_D}{d C_L} \approx \frac{C_{D,i+1} - C_{D,i}}{C_{L,i+1} - C_{L,i}}
$$

経験則として、$\left| s_i \right| < 0.05$ 程度の範囲を「線形領域（まだ剥離していないきれいな放物線領域）」とみなしてデータを抽出（フィルタリング）し、そのデータセットに対して上記のフィッティングを行うことで精度を担保しています。

---

## 実際に動かしてみる

作成したPythonスクリプトで解析した結果がこちらです。
青い点がXFLR5の生データ、オレンジの線が自動計算された近似モデルです。

[ここにXFLR5の点群と近似曲線が重なったグラフの画像を貼る]

**完全に一致していますね。**
特に抗力（右のグラフ）の放物線近似は、低抵抗領域において極めて高い一致度を示しています。これなら安心してXROTORに放り込めます。

## まとめ

ここまで来れば、あとはプログラムに落とし込むのは容易です。いまはAIでコーディングできる時代ですからね。私は、この理論に基づいて自動的に近似モデルを作成し、その結果をXFLR5の解析データと比較しながらパラメータを調整し、最終的に自分好みの近似モデルに仕上げられるようなPythonプログラムを作成しました。

もし興味のある方がいれば、お気軽にご連絡ください。